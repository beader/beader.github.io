<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>机器学习笔记-VC Dimension, Part I | Beader&#39;s blog</title>
  <meta name="author" content="beader">
  
  <meta name="description" content="something about Statistics, Data Mining and R">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="机器学习笔记-VC Dimension, Part I"/>
  <meta property="og:site_name" content="Beader&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Beader&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <% if (theme.google_analytics){ %>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', '<%= theme.google_analytics %>']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<% } %>
  
    <!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Beader&#39;s blog</a></h1>
  <h2><a href="/">something about Statistics, Data Mining and R</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">关于</a></li>
    
    <li><a href="/atom.xml">RSS</a></li>
    <li> <a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() {
	function c() {
		var e = document.createElement("link");
		e.setAttribute("type", "text/css");
		e.setAttribute("rel", "stylesheet");
		e.setAttribute("href", f);
		e.setAttribute("class", l);
		document.body.appendChild(e)
	}
 
	function h() {
		var e = document.getElementsByClassName(l);
		for (var t = 0; t < e.length; t++) {
			document.body.removeChild(e[t])
		}
	}
 
	function p() {
		var e = document.createElement("div");
		e.setAttribute("class", a);
		document.body.appendChild(e);
		setTimeout(function() {
			document.body.removeChild(e)
		}, 100)
	}
 
	function d(e) {
		return {
			height : e.offsetHeight,
			width : e.offsetWidth
		}
	}
 
	function v(i) {
		var s = d(i);
		return s.height > e && s.height < n && s.width > t && s.width < r
	}
 
	function m(e) {
		var t = e;
		var n = 0;
		while (!!t) {
			n += t.offsetTop;
			t = t.offsetParent
		}
		return n
	}
 
	function g() {
		var e = document.documentElement;
		if (!!window.innerWidth) {
			return window.innerHeight
		} else if (e && !isNaN(e.clientHeight)) {
			return e.clientHeight
		}
		return 0
	}
 
	function y() {
		if (window.pageYOffset) {
			return window.pageYOffset
		}
		return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
	}
 
	function E(e) {
		var t = m(e);
		return t >= w && t <= b + w
	}
 
	function S() {
		var e = document.createElement("audio");
		e.setAttribute("class", l);
		e.src = i;
		e.loop = false;
		e.addEventListener("canplay", function() {
			setTimeout(function() {
				x(k)
			}, 500);
			setTimeout(function() {
				N();
				p();
				for (var e = 0; e < O.length; e++) {
					T(O[e])
				}
			}, 15500)
		}, true);
		e.addEventListener("ended", function() {
			N();
			h()
		}, true);
		e.innerHTML = " <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>";
		document.body.appendChild(e);
		e.play()
	}
 
	function x(e) {
		e.className += " " + s + " " + o
	}
 
	function T(e) {
		e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]
	}
 
	function N() {
		var e = document.getElementsByClassName(s);
		var t = new RegExp("\\b" + s + "\\b");
		for (var n = 0; n < e.length; ) {
			e[n].className = e[n].className.replace(t, "")
		}
	}
 
	var e = 30;
	var t = 30;
	var n = 350;
	var r = 350;
	var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3";
	var s = "mw-harlem_shake_me";
	var o = "im_first";
	var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];
	var a = "mw-strobe_light";
	var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";
	var l = "mw_added_css";
	var b = g();
	var w = y();
	var C = document.getElementsByTagName("*");
	var k = null;
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			if (E(A)) {
				k = A;
				break
			}
		}
	}
	if (A === null) {
		console.warn("Could not find a node of the right size. Please try a different page.");
		return
	}
	c();
	S();
	var O = [];
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			O.push(A)
		}
	}
})()    '>High一下</a> </li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-23T05:00:00.000Z"><a href="/2014/01/23/vc-dimension-one/">1月 23 2014</a></time>
      
      
  
    <h1 class="title">机器学习笔记-VC Dimension, Part I</h1>
  

    </header>
    <div class="entry">
      
        <p>笔记整理自台大林轩田老师的开放课程-<a href="https://www.coursera.org/course/ntumlone" target="_blank" rel="external">机器学习基石</a>，笔记中所有图片来自于课堂讲义。</p>
<p>&emsp;&emsp;<a href="http://beader.me/2014/01/15/is-learning-feasible/" target="_blank" rel="external">上一篇</a>讲到，learning的时候如果遇上bad sample，如果遇上bad sample我们就无法保证$E_{in}$和$E_{out}$很接近。我们用了一个不等式来衡量遇上bad sample的概率：</p>
<p>$$\mathbb{P}_\mathcal{D}[BAD\ D]\leq 2Mexp(-2\epsilon ^2N)$$</p>
<p><a id="more"></a><br>&emsp;&emsp;因此如果Hypothesis Set中方程的数量$|\mathcal{H}|=M$是有限个，并且N足够大的时候，我们就有很大的概率保证不会遇上bad sample，即不管$\mathcal{A}$挑选了任意一个$g$，都可以保证$E_{out}(g) \approx E_{in}(g)$。因此learning的问题可以聚焦到以下两个问题：</p>
<ol>
<li>能不能确保$E_{in}(g)$和$E_{out}(g)$很接近？(Hypothesis Set中方程的个数会不会太多，用来训练的数据量够不够大)</li>
<li>能不能使$E_{in}(g)$足够小？(Hypothesis Set中方程的个数会不会太少)  </li>
</ol>
<p>&emsp;&emsp;这里我们便遇到了一个两难的选择：</p>
<ul>
<li>如果M很小，根据$\mathbb{P}[BAD]\leq 2Mexp(…)$，第1个问题，“很接近”，做的不错。但是对于第2个问题，由于选择性太少，很难找到$E_{in}(g)$较小的$g$。(想象一下如果数据是由一个二次方程所产生，而Hypothesis Set当中只有直线方程可以选)</li>
<li>如果M很大，我们选择方程的时候更加自由(自由度)，更有机会选到$E_{in}$很低的方程。但这个时候根据公式，我们遇到bad sample的可能性也大大增加。</li>
</ul>
<p>&emsp;&emsp;因此这篇笔记主要围绕公式中这个$M$展开：</p>
<p>$$\mathbb{P}[| E_{in}(g) - E_{out}(g) | \gt \epsilon] \leq 2\cdot M \cdot exp(-2\epsilon ^2N)$$</p>
<h2 id="有效的方程_(Effective_Number_of_Hypotheses)">有效的方程 (Effective Number of Hypotheses)</h2>
<p>&emsp;&emsp;让我们来回忆下这个M是从哪里来的。记$\mathcal{H}$中第m个方程遇到bad sample为事件$\mathcal{B}_m:|E_{in}(h_m) - E_{out}(h_m)| \gt \epsilon$，则$\mathcal{H}$遇到bad sample的概率为其所有方程遇到bad sample概率的联合概率。如果每个方程遇上bad sample这件事是互相独立的，则$\mathcal{H}$遇上bad sample的概率是各方程遇上bad sample的概率之和，因此他们的联合概率一定小于等于各个事件单独发生的概率之和。</p>
<p>$$\mathbb{P}[\mathcal{B}_1 or \mathcal{B}_2 or … or \mathcal{B}_M] \leq \mathbb{P}[\mathcal{B}_1] + \mathbb{P}[\mathcal{B}_2] + … + \mathbb{P}[\mathcal{B}_M]$$</p>
<p>&emsp;&emsp;但事实上bad event并不是完全独立的。想象$\mathcal{H}$两个非常类似的方程$h_1\approx h_2$，他们遇到bad sample分别为事件$\mathcal{B}_1$与$\mathcal{B}_2$，因为这两个方程很接近，则往往$\mathcal{B}_1$发生时，$\mathcal{B}_2$也会发生，可以说$\mathcal{B}_1$与$\mathcal{B}_2$的重合度很高(overlapping)。</p>
<p><img src="/imgs/vc-dimension-one/hypothesis_overlap.png" alt="" title="hypothesis_overlap.png"></p>
<p>&emsp;&emsp;那么我们就会想，我们能不能把结果接近的那些方程看成一类，譬如有些方程他们的预测结果总是相同或是很接近的。</p>
<p>&emsp;&emsp;假设我们的算法要在平面上挑选一条直线方程作为$g$,$\mathcal{H}={all\ lines\ in\  \mathbb{R}^2}$，$\mathcal{H}$当中有无限多个方程，但我们可以把这些个方程归为两类。一类是把$x_1$判断成圈圈的，另一类是把$x_1$判断为叉叉的。</p>
<p><img src="/imgs/vc-dimension-one/1point2lines.png" alt="" title="1point2lines.png"></p>
<p>&emsp;&emsp;那如果我们手中有2个数据点$x_1$和$x_2$呢？这样的话$\mathcal{H}$中无数条直线可以分为4类。用这4类线对$x_1$和$x_2$进行预测，一共能产生4种不同的结果。</p>
<p><img src="/imgs/vc-dimension-one/2points4lines.png" alt="" title="2points4lines.png"></p>
<p>&emsp;&emsp;那如果我们手中有3个数据点$x_1$、$x_2$和$x_3$呢？</p>
<p><img src="/imgs/vc-dimension-one/3points8lines.png" alt="" title="3points8lines.png">  </p>
<p>&emsp;&emsp;$\mathcal{H}$中最多有8类直线，作用于$\mathcal{D}$产生如上8种结果。</p>
<p>&emsp;&emsp;那如果我们手中有4个数据点$x_1$~$x_4$，情况又会是怎样。前面的例子中我们基本上把各个数据点的情况用排列组合的方式组合出来即可。但对于4个以上的点而言，就不是那么容易了。</p>
<p><img src="/imgs/vc-dimension-one/4points14lines.png" alt="" title="4points14lines.png"><br>&emsp;&emsp;在这16种组合中，就有两种是“直线方程”没有办法产生的结果。因此如果$\mathcal{H}$是2维空间中的所有直线，表面上看是在无数条直线方程中去挑，但由于大部分直线方程所产生的结果是一模一样的，结果不一样的直线的类别对应上面的例子分别为2类、4类、8类和14类(Effective Number of Lines)。属于同一类的直线，他们将同时遇到或不遇到bad sample，由于之前那个union bound是基于独立性的假设下的，因此$\mathcal{H}$遭遇bad sample的概率明显被夸大了。所以，我们应该把不等式改写为：</p>
<p>$$\mathbb{P}[|E_{in}(g)-E_{out}(g)|\gt \epsilon]\leq 2\cdot effective(N)\cdot exp(-2\epsilon^2N)$$</p>
<h2 id="$\mathcal{H}$作用于$\mathcal{D}$能够产生多少不同的结果？_(Dichotomies)">$\mathcal{H}$作用于$\mathcal{D}$能够产生多少不同的结果？ (Dichotomies)</h2>
<p>&emsp;&emsp;从$\mathcal{H}$中任意选取一个方程$h$，让这个$h$对$\mathcal{D}$进行二元分类，输出一个结果向量，比如对4个点进行预测，输出${\mathrm{o},\mathrm{o},\mathrm{o},\times}$，这样的一个输出向量我们称它为一个dichotomy。不难得出，一个直线方程在$\mathcal{D}$中对应一个dichotomy，但一个dichotomy至少对应一个直线方程，我们把一个dichotomy对应的所有直线方程视为一类，则effective number of lines就等于不同$\mathcal{D}$中不同的dichotomy的数量。显然这个dichotomy的数量小于等于所有数据点的排列组合数的，例如上图中画大叉的那幅图对应的排列组合，就不能成为一个dichotomy，因为它们无法由任何一条直线方程产生。（当然如果考虑的不是直线方程，则那种排列组合是可以成为一种dichotomy的）<br>&emsp;&emsp;因此我们前面要找的<br>&emsp;&emsp;$effective(N)$<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;=平面中能找出多少条不同类的直线<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;=$\mathcal{H}$作用于$\mathcal{D}$能产生多少不同的dichotomy。<br>&emsp;&emsp;因为不一定所有排列组合都能成为dichotomy，所以不同的dichotomy的数量一定不会超过排列组合数$2^N$，上例中如果存在三点共线的情况，则dichotomy的数量会更少，因此：<br>&emsp;&emsp;$effective(N)$<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;=$\mathcal{H}$作用于$\mathcal{D}$“<strong>最多</strong>”能产生多少不同的dichotomy</p>
<h2 id="成长函数_(Growth_Function)">成长函数 (Growth Function)</h2>
<p>&emsp;&emsp;那么，$\mathcal{H}$作用于$\mathcal{D}$“<strong>最多</strong>”能产生多少种不同的dichotomy呢？这个数量与$\mathcal{H}$有关，也与数据量$N$有关。用数学式可以表达为：</p>
<p>$$max|\mathcal{H}(x_1,x_2,…,x_N)|$$</p>
<p>&emsp;&emsp;上式又称为成长函数（growth function）。在$\mathcal{H}$确定的情况下，growth function是一个与N相关的函数。以下是几种常见的Hypothesis Set的成长函数。</p>
<ol>
<li><p>Positive Rays<br><img src="/imgs/vc-dimension-one/postive_rays.png" alt="" title="postive_rays.png"><br>输入空间为一维实数空间。大于threshold a的预测+1,否则预测-1。<br>for example: 当N=4时，Positive Rays作用于$x_1$~$x_4$，共能产生5个不同的dichotomies。如下图：<br><img src="/imgs/vc-dimension-one/positive_rays_dichotomies.png" alt="" title="positive_rays_dichotomies.png"><br>不难去想，4个点，5个可能的切点，最多产生5种dichotomies。因此Positive Rays的成长函数为：<br>$$m_{\mathcal{H}(N)}=N+1$$</p>
</li>
<li><p>Positive Intervals<br><img src="/imgs/vc-dimension-one/positive_intervals.png" alt="" title="positive_intervals.png"><br>和前面的类似，只不过Positive Intervals有两个threshold，夹在两个threshold之间的预测为+1，其余预测为-1。<br>for example: 当N=4时，Positive Intervals作用于$x_1$~$x_4$，共能产生11种dichotomies。如下图：<br><img src="/imgs/vc-dimension-one/positive_intervals_dichotomies.png" alt="" title="positive_intervals_dichotomies.png"><br>同样不难去想，4个点，5个可能的切点选两个作为threshold，加上两个threshold重合产生的一种，因此Positive Intervals的成长函数为：<br>$$m_{\mathcal{H}(N)}=\binom{N+1}{2} + 1 = \frac{1}{2}N^2 + \frac{1}{2}N + 1$$</p>
</li>
<li><p>Convex Sets<br><img src="/imgs/vc-dimension-one/convex_sets.png" alt="" title="convex_sets.png"><br>任选k个点，在这k个点组成的convex多边形包围内的所有点都预测+1，否则预测-1。前面我们说到成长函数描述的是“<strong>最多</strong>”能产生的dichotomy种数，因此如果我们这N个input摆成一个圈，则这N个点的任意一种排列组合都能成为一个dichotomy。因此Convex Sets的成长函数为：<br>$$m_{\mathcal{H}(N)}=2^N$$</p>
</li>
</ol>
<h2 id="坏掉的散弹枪_(Shatter_&amp;_Break)">坏掉的散弹枪 (Shatter &amp; Break)</h2>
<p>&emsp;&emsp;当$\mathcal{H}$作用于有N个inputs的$\mathcal{D}$时，产生的dichotomies数量等于这N个点的排列组合数$2^N$时，我们就称这N个inputs被$\mathcal{H}$给shatter掉了。或者也可以说$\mathcal{H}$产生的$2^N$个dichotomies把这N个点的$2^N$种排列组合给shatter了。</p>
<p>&emsp;&emsp;这个shatter的意思似乎不太好理解，这是林老师在讨论区中的回复：</p>
<p>&emsp;&emsp;“大家對 break point 的討論很好，不過注意到 shatter 的原意是「打碎」，在此指「N 個點的所有(碎片般的)可能情形都被$\mathcal{H}$產生了」。所以$m_{\mathcal{H}}(N)=2^N$ 的情形是「shatter」。”</p>
<p>&emsp;&emsp;我从打游戏过关的角度去理解，shatter作打碎理解：</p>
<p>&emsp;&emsp;“$m_{\mathcal{H}}$是把散弹枪，在每个关卡(level N)中，他可以有$m_{\mathcal{H}}(N)$发小子弹（每发小子弹对应一种dichotomy），而你面临的是$2^N$个敌人。你得一枪打出去shatter掉所有人。对于$m_{\mathcal{H}}(N)=2N$这把散弹枪来说，第一关和第二关都还好，第三关6发小子弹shatter不掉8个人，于是它就break了。”</p>
<p>&emsp;&emsp;对于给定的成长函数$m_{\mathcal{H}}(N)$，从$N=1$出发，N慢慢增大，当增大到k时，出现$m_{\mathcal{H}}(k)\lt 2^k$的情形，则我们说k是该成长函数的break point，对于任何$N \gt k$个inputs而言，$\mathcal{H}$都没有办法再shatter他们。</p>
<p>&emsp;&emsp;不难根据成长函数得出Positive Rays成长函数的break point为2，Positive Intervals成长函数的break point为3，Convex Sets不管N多大都可以去shatter掉那N个点，因此它的成长函数没有break point。2D Perceptrons的break point为4，因为在N=3时，它都能够shatter，产生$2^3=8$种dichotomies，当N=4时，它不能够shatter，最多只能产生14 ($\lt 2^4 = 16$) 种dichotomies，因此2D Perceptrons成长函数的break point为4。</p>
<h2 id="拿什么来镇镇成长函数_(Restriction_of_Break_Point)">拿什么来镇镇成长函数 (Restriction of Break Point)</h2>
<p>&emsp;&emsp;有些$\mathcal{H}$的成长函数很容易找到，比如前面说到的Positive Rays、Positive Intervals以及Convex Sets；有些$\mathcal{H}$则没有那么容易，比如2D perceptrons，我们无法直接看出它的成长函数是什么，那么我们对于这样的$\mathcal{H}$就没辙了吗？也不完全是，至少我们手上还掌握着它的break point，能不能用这个break point干点事呢？如果没办法得到成长函数，能得到成长函数的upper bound也是不错的。</p>
<p>&emsp;&emsp;先用例子来看看，当我们完全不知道$\mathcal{H}$是什么，只知道它的break point k时，$\mathcal{H}$作用于$\mathcal{D}$“<strong>最多最多</strong>”可以产生多少这dichotomies。注意这里我用了两个“<strong>最多</strong>”，由于我们无法确切知道成长函数，因此我们用这个break point推算出的这个dichotomies的数量仍然是个高估值，这个高估值实际上是任何break point为k的$\mathcal{H}$作用于$\mathcal{D}$所真实产生的dichotomies数量的上界 (upper bound)。</p>
<p>&emsp;&emsp;举例说明，假设我们不知道某个$\mathcal{H}$的成长函数$m_{\mathcal{H}}(N)$，但知道它的break point k=2，那么$\mathcal{H}$作用于N=3的$\mathcal{D}$时，“<strong>最多最多</strong>”能产生多少种dichotomies？</p>
<p>&emsp;&emsp;从k=2我们可以知道，任意2个数据点都不能被shatter。还记得shatter的概念吗？意思就是我产生的dichotomies不能完全包含任何2个数据点所有的排列组合。让我们从1个dichotomy开始。</p>
<p>1 dichotomy <img src="/imgs/vc-dimension-one/n3k2d1.png" alt="" title="n3k2d1.png"></p>
<p>2 dichotomies <img src="/imgs/vc-dimension-one/n3k2d2.png" alt="" title="n3k2d2.png"></p>
<p>3 dichotomies <img src="/imgs/vc-dimension-one/n3k2d3.png" alt="" title="n3k2d3.png"></p>
<p>&emsp;&emsp;注意看$x_2$和$x_3$这两列，这3个dichotomies已经包含$x_2$和$x_3$这两个点所有的4种排列组合中的3种了。再多加一种，$x_2$、$x_3$就会被shatter。</p>
<p>4 dichotomies <img src="/imgs/vc-dimension-one/n3k2d4s.png" alt="" title="n3k2d4s.png"></p>
<p>&emsp;&emsp;看右边两列，$x_2$和$x_3$被shatter了。但之前说了k=2，即任意2个点不能被shatter，因此不可能产生这4种dichotomies。那我们换一个dichotomy试试看。</p>
<p>4 dichotomies <img src="/imgs/vc-dimension-one/n3k2d4.png" alt="" title="n3k2d4.png"></p>
<p>&emsp;&emsp;换了一个dichotomy之后就行了，右边2列只包含了$x_2$、$x_3$所有排列组合4种中的3种，因此那两个点没有被shatter。继续检查任意的两个点($x_1$、$x_2$)，($x_1$、$x_3$)，都没有被shatter，看来这4种dichotomies是可以的。</p>
<p>&emsp;&emsp;5个dichotomies的情形这里就不再画出来了，很容易看出不管增加怎样的dichotomy进去，都会有两个点被shatter掉。因此这里“<strong>最多最多</strong>”只能有4种dichotomies。因此$N=3$，$k=2$时的upper bound是4。我们用$B(N,k)$来表示break point为k的任意的$\mathcal{H}$作用于size为N的任意的$\mathcal{D}$所能产生的dichotomies的数量的上限（“<strong>最多最多</strong>”）。则刚刚得出的结论可以表示为$B(3,2)=4$，因为任意2个数据点不能被shatter，因此当$N=2,K=2$时，$B(2,2)\lt 4$，因此最多最多有$B(2,2)=3$。</p>
<p>&emsp;&emsp;美妙的地方马上就要到了，虽然很多时候我们无法直接得到成长函数$m_{\mathcal{H}}(N)$，但如果我们知道它的break point是多少，我们似乎还是有办法算出这个$m_{\mathcal{H}}(N)$的上界$B(N,k)$的。于是乎我们就有了新的目标，不去直接研究$m_{\mathcal{H}}(N)$，转而去研究$B(N,k)$。</p>
<p>&emsp;&emsp;前面我们已知了$B(2,2)=3$，$B(3,2)=4$。不难知道：</p>
<ul>
<li>$k=1$时，1个点(2种排列组合)都没有办法shatter，因此$B(?,1)$恒等于1。</li>
<li>$k&gt;N$时，$\mathcal{H}$一定能shatter掉$N$个点，因此它产生的dichotomies的种类等于这$N$个点所有的排列组合数$2^N$。</li>
<li>$k=N$时，从$2^N$个排列组合中移除掉一个，剩下的都可以作为dichotomies，因此它产生的dichotomies的数量“<strong>最多最多</strong>”可以是$2^N-1$。</li>
</ul>
<p>&emsp;&emsp;因此我们可以得到下表：</p>
<p><img src="/imgs/vc-dimension-one/bnk_table.png" alt="" title="bnk_table.png"></p>
<p>&emsp;&emsp;表格剩余的部分该如何填补？$B(4,3)$是否与$B(3,?)$有关呢？<br>&emsp;&emsp;此时某某实验室帮老师抛硬币的研究生要上场了，他穷举了所有可能的dichotomies，发现$B(4,3)=11$，以下是他的研究成果：</p>
<p><img src="/imgs/vc-dimension-one/n4k3d11.png" alt="" title="n4k3d11.png"></p>
<p>&emsp;&emsp;我们把这份结果做个排序：</p>
<p><img src="/imgs/vc-dimension-one/n4k3d11_ordered.png" alt="" title="n4k3d11_ordered.png"></p>
<p>&emsp;&emsp;发现秘密了没有，橙色的部分是成对出现的，只有紫色的部分是单独出现的：</p>
<p><img src="/imgs/vc-dimension-one/n4k3d11_ordered2.png" alt="" title="n4k3d11_ordered2.png"> </p>
<ol>
<li><p>如果拿掉$x_4$，只看$x_1,x_2,x_3$这3个点：<br><img src="/imgs/vc-dimension-one/n4k3d7.png" alt="" title="n4k3d7.png"><br>&emsp;&emsp;$\alpha + \beta$部分可以成为这3个点的dichotomies，因为$k=3$，所以任3个点不能够被shatter，因此有：：<br>$$\alpha + \beta \leq B(3,3)$$</p>
</li>
<li><p>再来看剩下一个$\alpha$的部分：<br><img src="/imgs/vc-dimension-one/n4k2_alpha.png" alt="" title="n4k2_alpha.png"><br>&emsp;&emsp;注意$\alpha$是之前成对存在的部分，并且$\alpha$部分不可以shatter掉任意2个点，因为如果$\alpha$部分的dichotomies可以shatter掉任意2个点，他每一行都再搭配$x_4$的两种情况，这样产生的dichotomies就能shatter掉3个点了，和break point为3相违背。所以$\alpha$不能shatter掉任2个点。因此有：<br>$$\alpha \leq B(3,2)$$</p>
</li>
</ol>
<p>&emsp;&emsp;综合上面两个不等式，我们可以得到：<br>$$B(4,3)=2\alpha + \beta \leq B(3,3) + B(3,2)$$</p>
<p>&emsp;&emsp;这样就能够把前面那张表给填完整：</p>
<p><img src="/imgs/vc-dimension-one/bnk_table_full.png" alt="" title="bnk_table_full.png"></p>
<script type="math/tex; mode=display">
\begin{aligned}
B(N,k) &= 2\alpha + \beta \\\
\alpha + \beta &\leq B(N-1,k) \\\
\alpha &\leq B(N-1,k-1) \\\
\Rightarrow B(N,k) &\leq B(N-1,k) + B(N-1,k-1)
\end{aligned}
</script>

<p>&emsp;&emsp;用数学归纳法可以证明：<br>$$B(N,k)\leq \sum_{i=0}^{k-1}\binom {N}{i}$$</p>
<p>&emsp;&emsp;当$k=1$时不等式恒成立，因此只要讨论$k\geq 2$的情形。$N=1$时，不等式成立，假设$N\leq N_{o}$时对于所有的$k$不等式都成立，则我们需要证明当$N=N_{o}+1$时，不等式也成立。根据前面得到的结论，有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
B(N_{o}+1,k) &\leq B(N_{o},k) + B(N_{o},k-1) \\\
&\leq \sum_{i=0}^{k-1}\binom{N_{o}}{i}+\sum_{i=0}^{k-2}\binom{N_{o}}{i} \\\
&=1+\sum_{i=1}^{k-1}\binom{N_{o}}{i}+\sum_{i=1}^{k-1}\binom{N_{o}}{i-1} \\\
&=1+\sum_{i=1}^{k-1}[\binom{N_{o}}{i}+\binom{N_{o}}{i-1}] \\\
&=1+\sum_{i=1}^{k-1}\binom{N_{o}+1}{i}=\sum_{i=0}^{k-1}\binom{N_{o}+1}{i}
\end{aligned}
</script>

<p>&emsp;&emsp;因此当$N=N_{o}+1$时，不等式也成立。</p>
<p>&emsp;&emsp;成长函数的上界-$B(N,k)$都被bound住了，那我们的成长函数同样也可以被这个bound住，因此对于存在break point k的成长函数而言，有：<br>$$m_{\mathcal{H}}\leq \sum_{i=0}^{k-1}\binom {N}{i}$$<br>&emsp;&emsp;By the way，右手边(RHS)实际上是一个最高次项为k-1次的多项式。以2D Perceptrons为例，它的break point $k=4$，则它的成长函数会被$B(N,4)$给bound住：<br>$$m_{\mathcal{H}}\leq \sum_{i=0}^{4-1}\binom {N}{i}=\frac{1}{6}N^3+\frac{5}{6}N+1$$</p>
<h2 id="总结">总结</h2>
<p>&emsp;&emsp;上一篇说的learning的可行性，讲到，如果遇上bad sample，$E_{in}(h)$与$E_{out}(h)$就会差很多，此时learning不可行。遇到bad sample的概率与$\mathcal{H}$中方程的数量$M$以及$\mathcal{D}$中的数据量$N$有关。然而$\mathcal{H}$中方程的数量往往是无穷的(比如2D Perceptrons的$\mathcal{H}$是平面上所有的直线)，本篇则继续阐述，方程的数量看上去是无穷的，但真正有效(effective)的方程的数量却是有限的，我们可以用成长函数$m_{\mathcal{H}}(N)$来描述$\mathcal{H}$作用于$\mathcal{D}$会产生多少种有效的方程。如果用有限的成长函数去代替无限的$M$，就有：</p>
<p>$$\mathbb{P}_\mathcal{D}[BAD\ D]\leq 2m_{\mathcal{H}}(N)\cdot exp(-2\epsilon ^2N)$$</p>
<p>&emsp;&emsp;但实际上我们很难确切知道各种$\mathcal{H}$的成长函数$m_{\mathcal{H}}(N)$究竟长什么样子，我们只好通过break point去寻找成长函数的upper bound。不过这当中仍然有些情况没有考虑到，将在下一篇笔记中继续说明。</p>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/Machine-Learning/">Machine Learning</a>, <a href="/tags/VC-Dimension，成长函数-(growth-function)/">VC Dimension，成长函数 (growth function)</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>



  喜欢就分享一下吧
  <div class="bdsharebuttonbox">
  
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
  
  
    <a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a>
  
  
    <a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a>
  
  
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
  
  
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
  
  
</div>
  <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdPic":"","bdStyle":"0","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">

<!-- Duoshuo Comment BEGIN -->
<div class="ds-thread"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"beader"};
  (function() {
 	var ds = document.createElement('script');
	ds.type = 'text/javascript';ds.async = true;
	ds.src = 'http://static.duoshuo.com/embed.js';
	ds.charset = 'UTF-8';
	(document.getElementsByTagName('head')[0] 
	|| document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END -->

</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:beader.me">
  </form>
</div>

  <div class="widget tag">
<h3 class="title">整理</h3>
<ul class="entry">
<li><a href="http://beader.me/mlnotebook/" title="Machine Learning Notebook">机器学习笔记(Open Book)</a></li>
</ul>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Error-Measure/">Error Measure</a><small>1</small></li>
  
    <li><a href="/tags/Hoeffding’s-Inequality/">Hoeffding’s Inequality</a><small>1</small></li>
  
    <li><a href="/tags/Logistic-Regression/">Logistic Regression</a><small>2</small></li>
  
    <li><a href="/tags/Machine-Learning/">Machine Learning</a><small>7</small></li>
  
    <li><a href="/tags/MapReduce/">MapReduce</a><small>1</small></li>
  
    <li><a href="/tags/Noise/">Noise</a><small>1</small></li>
  
    <li><a href="/tags/ODPS/">ODPS</a><small>1</small></li>
  
    <li><a href="/tags/R/">R</a><small>3</small></li>
  
    <li><a href="/tags/VC-Dimension，成长函数-(growth-function)/">VC Dimension，成长函数 (growth function)</a><small>2</small></li>
  
    <li><a href="/tags/VC-Dimension，自由度(degree-of-freedom)/">VC Dimension，自由度(degree of freedom)</a><small>1</small></li>
  
    <li><a href="/tags/auc/">auc</a><small>1</small></li>
  
    <li><a href="/tags/classification-tree/">classification tree</a><small>1</small></li>
  
    <li><a href="/tags/ggplot2/">ggplot2</a><small>1</small></li>
  
    <li><a href="/tags/gini-coefficient/">gini coefficient</a><small>1</small></li>
  
    <li><a href="/tags/human-activity-recognition/">human activity recognition</a><small>1</small></li>
  
    <li><a href="/tags/pla/">pla</a><small>2</small></li>
  
    <li><a href="/tags/plyr/">plyr</a><small>1</small></li>
  
    <li><a href="/tags/r/">r</a><small>1</small></li>
  
    <li><a href="/tags/random-forest/">random forest</a><small>2</small></li>
  
    <li><a href="/tags/rcurl/">rcurl</a><small>1</small></li>
  
    <li><a href="/tags/roc/">roc</a><small>1</small></li>
  
    <li><a href="/tags/text-mining/">text mining</a><small>1</small></li>
  
    <li><a href="/tags/word-cloud/">word cloud</a><small>1</small></li>
  
    <li><a href="/tags/偏导数-(partial-derivative)/">偏导数 (partial derivative)</a><small>1</small></li>
  
    <li><a href="/tags/分类器/">分类器</a><small>1</small></li>
  
    <li><a href="/tags/帽子矩阵(Hat-Matrix)/">帽子矩阵(Hat Matrix)</a><small>1</small></li>
  
    <li><a href="/tags/感知机-(perceptron)/">感知机 (perceptron)</a><small>1</small></li>
  
    <li><a href="/tags/梯度下降-(gradient-decent)/">梯度下降 (gradient decent)</a><small>1</small></li>
  
    <li><a href="/tags/线性回归(Linear-Regression)/">线性回归(Linear Regression)</a><small>2</small></li>
  
    <li><a href="/tags/统计图表/">统计图表</a><small>1</small></li>
  
    <li><a href="/tags/非线性转换(Nonlinear-Transformation)/">非线性转换(Nonlinear Transformation)</a><small>1</small></li>
  
  </ul>
</div>


  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://ytliu.info/" title="McTrain's Blog">McTrain's Blog</a></li>
<li><a href="http://lemoner.me//" title="Lemon's Blog">Lemon's Blog</a></li>
</ul>
</div>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 beader
  
</div>
<div class="clearfix"></div></footer>
  <script src="//cdnjscn.b0.upaiyun.com/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>




<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F96088bf0972512652719efc549bd275b' type='text/javascript'%3E%3C/script%3E"));
</script>


</body>
</html>